#!/bin/bash

# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the Free
# Software Foundation; either version 2 of the License, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA



### Functions ###
temp=$(dirname "$0")
source "$temp/functions-common.sh"
source "$temp/functions-test.sh"
unset temp

section_is_enabled ()
{
  local regex section parent

  # all sections are enabled
  [ -z "$sections" ] && return 0

  # this section or at least one of its subsections is enabled
  [ "$1" = '--sub' ] && {
    regex=" $2(.[^ ]+)? "
    [[ $sections =~ $regex ]] && return 0
  }

  # this section is enabled (by itself or by one of its parents)
  parent=$1
  while [ "$section" != "$parent" ]; do
    section=$parent
    [[ $sections == *" $section "* ]] && return 0
    parent=${section%.*}
  done

  # this section is not enabled
  return 1
}

create_tempfiles ()
{
  local -i i n=${#tempfiles[@]}
  local    tempfile

  (($1 > 0)) || abort "${FUNCNAME[0]}(): Wrong argument '$1'"

  # create as many new temporary files as needed
  for ((i = $1 - n; i > 0; i--)); do
    tempfile=$(mktemp) || abort 'file' && tempfiles+=("$tempfile")
    base64 /dev/urandom | sed 's/[a-d]/ /g; s/[e-h]/\t/g; 11q' >"$tempfile"
  done
}



### Preamble ###

# Global variables
declare -r timeout='timeout -v -k 5 -- 10' script_name=${0##*/}
declare -a ignored warnings errors tempfiles
declare -i quiet=0 n_warns=0 n_errs=0 n_cmds=0
declare    mousepad logfile logdir sections

# Option parsing
temp=$(getopt -o 'hqc:l:s:i:' \
  -l 'help,quiet,command:,logfile:,section:,list-sections,ignore:' \
  -n "$0" -- "$@"
) || exit 1

eval set -- "$temp" && unset temp

section_list=(
  'non-gui'
  'simple-gui' 'simple-gui.no-file' 'simple-gui.one-file' 'simple-gui.multi-file'
  'gsettings' 'gsettings.no-file' 'gsettings.preferences' 'gsettings.one-file'
              'gsettings.multi-tab' 'gsettings.multi-window'
  'actions' 'actions.off-menu' 'actions.file' 'actions.edit' 'actions.search'
            'actions.view' 'actions.document' 'actions.help'
)

while [ "$1" != '--' ]; do
  case $1 in
  '-h'|'--help')
    cat <<EOF
Usage: $script_name [OPTION]...
  -h, --help		Display this help and exit
  -q, --quiet		Do not print any progress indication
  -c, --command=COMMAND	Path to the Mousepad executable to test (default: mousepad in \$PATH)
  -l, --logfile=LOGFILE	Path to the logfile for writing the test report (default: "\$PWD/$script_name.log")
  -s, --section=SECTION	Test section to run (can be used several times, default: all sections)
      --list-sections	List possible test sections to run
  -i, --ignore=PATTERN	Ignore lines containing the ERE PATTERN in Mousepad output on stderr (can be used several times)

Exit code:
  0 when everything is fine
  1 when aborted
  2 when some commands issued warnings
  3 when some commands failed
  5 when 2 and 3
EOF
    exit 0
  ;;
  '-q'|'--quiet')
    quiet=1
  ;;
  '-c'|'--command')
    shift
    mousepad=$1
  ;;
  '-l'|'--logfile')
    shift
    logfile=$1
  ;;
  '-s'|'--section')
    shift

    [[ " ${section_list[*]} " != *" $1 "* ]] && {
      printerr 'error' "Invalid section name '$1'"
      exit 1
    }

    sections+=" $1 "
  ;;
  '--list-sections')
    printf '%s\n' "${section_list[@]}"
    exit 0
  ;;
  '-i'|'--ignore')
    shift
    ignored+=('-e')
    ignored+=("$1")
  ;;
  *)
    printerr 'error' "Invalid option '$1'"
    exit 1
  ;;
  esac

  shift
done

unset section_list

# Checks
mousepad=${mousepad:-'mousepad'}
which "$mousepad" &>/dev/null || {
  printerr 'error' "Command not found '$mousepad'"
  exit 1
}

logfile=${logfile:-"$PWD/$script_name.log"}
logdir=$(dirname "$logfile")
[ -d "$logfile" ] && {
  printerr 'error' "'$logfile' is a directory"
  exit 1
}
[ ! -w "$logdir" ] && {
  printerr 'error' "Directory '$logdir' is read-only"
  exit 1
}

which xdotool &>/dev/null || {
  printerr 'error' 'xdotool is required but does not seem to be installed'
  exit 1
}

which wmctrl &>/dev/null || {
  printerr 'error' 'wmctrl is required but does not seem to be installed'
  exit 1
}

[ -n "$(pgrep -x mousepad)" ] && {
  printerr 'error' 'Mousepad is running, all Mousepad instances should be terminated before running this script'
  exit 1
}

[ -z "$sections" ] && {
  read -s -n1 -p 'Are you sure you want to run all the test sections, this could take a while? ([y]es, [N]o) '
  echo $REPLY
  [[ $REPLY != [yY] ]] && exit 0 || echo
}

# Set some global constants
readonly quiet mousepad logfile logdir sections ignored

# From now on we write by default in the logfile
exec 1>"$logfile"



### Main ###

# Non-GUI commands
section_is_enabled 'non-gui' && {
  echo '*** Non-GUI commands ***' | duperr
  test_non_gui --list-encodings
  test_non_gui --version
}

# Simple GUI commands (`mousepad --quit` is implicitly tested each time, except with
# `--disable-server`)
section_is_enabled --sub 'simple-gui' \
  && printf '\n%s\n' '*** Simple GUI commands ***' | duperr

section_is_enabled 'simple-gui.no-file' && {
  echo '- No file -' | duperr
  test_simple_gui
  test_simple_gui --preferences
  test_simple_gui --disable-server
}

section_is_enabled 'simple-gui.one-file' && {
  echo '- One file -' | duperr
  create_tempfiles 1
  test_simple_gui "${tempfiles[0]}"
  test_simple_gui --encoding -- "${tempfiles[0]}"
  test_simple_gui --encoding=ISO-8859-15 -- "${tempfiles[0]}"
  test_simple_gui --line=2 --column=3 -- "${tempfiles[0]}"
}

section_is_enabled 'simple-gui.multi-file' && {
  echo '- Multi-file -' | duperr
  create_tempfiles 2
  test_simple_gui --opening-mode=tab -- "${tempfiles[@]}"
  test_simple_gui --opening-mode=window -- "${tempfiles[@]}"
}

# GSettings (setting change from cli when mousepad is running)
section_is_enabled --sub 'gsettings' \
  && printf '\n%s\n' '*** GSettings commands ***' | duperr

section_is_enabled 'gsettings.no-file' && {
  echo '- No file -' | duperr
  test_gsettings
}

section_is_enabled 'gsettings.preferences' && {
  echo '- Preferences -' | duperr
  test_gsettings --preferences
}

section_is_enabled 'gsettings.one-file' && {
  echo '- One file -' | duperr
  create_tempfiles 1
  test_gsettings "${tempfiles[0]}"
}

section_is_enabled 'gsettings.multi-tab' && {
  echo '- Multi-tab -' | duperr
  create_tempfiles 2
  test_gsettings --opening-mode=tab -- "${tempfiles[@]}"
}

section_is_enabled 'gsettings.multi-window' && {
  echo '- Multi-window -' | duperr
  create_tempfiles 2
  test_gsettings --opening-mode=window -- "${tempfiles[@]}"
}

# Actions (for the moment (Mousepad 0.5.5) only window actions are relevant: application actions
# are tested via gsettings or command line options above)
section_is_enabled --sub 'actions' && {
  create_tempfiles 1
  printf '\n%s\n' '*** Action commands ***' | duperr
}

section_is_enabled 'actions.off-menu' && {
  echo '- Off-menu -' | duperr
  test_actions --off-menu "${tempfiles[0]}"
}

section_is_enabled 'actions.file' && {
  echo '- File menu -' | duperr
  test_actions --file "${tempfiles[0]}"
}

section_is_enabled 'actions.edit' && {
  echo '- Edit menu -' | duperr
  test_actions --edit "${tempfiles[0]}"
}

section_is_enabled 'actions.search' && {
  echo '- Search menu -' | duperr
  test_actions --search "${tempfiles[0]}"
}

section_is_enabled 'actions.view' && {
  echo '- View menu -' | duperr
  test_actions --view "${tempfiles[0]}"
}

section_is_enabled 'actions.document' && {
  echo '- Document menu -' | duperr
  test_actions --document "${tempfiles[0]}"
}

section_is_enabled 'actions.help' && {
  echo '- Help menu -' | duperr
  test_actions --help "${tempfiles[0]}"
}

# Outcome
{
  printf '\n%s\n' '*** Outcome ***'
  ((n_warns > 0)) && echo "Some commands issued warnings: numbers ${warnings[*]}"
  ((n_errs > 0)) && echo "Some commands failed: numbers ${errors[*]}"
  ((n_warns == 0 && n_errs == 0)) && echo 'Nothing wrong to report'
} | duperr

# wait a bit until the above has been written on stderr
sleep 0.1
printerr "Full test report written in $logfile"

cleanup

exit $(( 2 * (n_warns > 0) + 3 * (n_errs > 0) ))
