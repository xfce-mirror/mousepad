#!/bin/bash

# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the Free
# Software Foundation; either version 2 of the License, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA



### Functions ###
printerr ()
{
  local prefix

  case $1 in
  'error')
    prefix='\033[1;31mError: \033[0m'
    shift
  ;;
  'warning')
    prefix='\033[1;33mWarning: \033[0m'
    shift
  ;;
  'message')
    prefix='\033[1;32mMessage: \033[0m'
    shift
  ;;
  *)
    prefix=''
  ;;
  esac

  printf '%b%s\n' "$prefix" "$1" >&2
}

duperr ()
{
  if ((quiet)); then
    tee /dev/null
  else
    tee >(cat >&2)
  fi
}

cleanup ()
{
  local f

  for f in "${tempfiles[@]}"; do
    [ -f "$f" ] && rm "$f"
  done
}

abort ()
{
  printf '\n%s\n' '*** Aborted ***' | duperr

  case $1 in
  'running')
    echo 'A previous Mousepad instance did not terminate'
  ;;
  'file')
    echo 'Creation of temporary file failed'
  ;;
  *)
    echo "$1"
  ;;
  esac | duperr

  cleanup

  exit 1
}

filter ()
{
  if [ -z "$ignored" ]; then
    cat
  else
    grep -E -v "${ignored[@]}"
  fi
}

test_non_gui ()
{
  local -a cmd
  local    out
  local -i r

  # exit if ever the previous mousepad instance didn't terminate
  [ -n "$(pgrep -x mousepad)" ] && abort 'running'

  # log and run the mousepad command
  cmd=("$mousepad" "$@")
  ((n_cmds++))
  echo "Command $n_cmds: ${cmd[*]}" | duperr

  out=$($timeout "${cmd[@]}" 2> >(filter) 1>/dev/null)
  r=$?

  # log results
  [ -n "$out" ] && {
    warnings[n_warns++]=$n_cmds
    sed 's/^/  /' <<<"$out"
    printf '%s\n\n' "Exit code: $r"
  }

  ((r != 0)) && {
    errors[n_errs++]=$n_cmds
    [ -z "$out" ] && printf '%s\n\n' "Exit code: $r"
  }
}

test_simple_gui ()
{
  local -a cmd
  local    out
  local -i r pid id

  # exit if ever the previous mousepad instance didn't terminate
  [ -n "$(pgrep -x mousepad)" ] && abort 'running'

  # log and run the mousepad command
  cmd=("$mousepad" "$@")
  ((n_cmds++))
  echo "Command $n_cmds: ${cmd[*]}" | duperr

  out=$(mktemp) || abort 'file'
  "${cmd[@]}" 2> >(filter >"$out") 1>/dev/null &
  pid=$!

  # wait for the window to appear on screen, meaning mousepad is idle
  id=$($timeout xdotool search --sync --onlyvisible --pid $pid | head -1) 2>&1
  $timeout pwait -x mousepad 2>&1 &
  pid=$!

  # quit as gracefully as possible, testing `mousepad --quit` in various contexts by the way
  if ((id != 0)); then
    if [[ $* != *--disable-server* ]]; then
      # purge the logs
      [ -s "$out" ] && {
        warnings[n_warns++]=$n_cmds
        sed 's/^/  /' <"$out"
        >"$out"
      }

      # log and run the quit command
      ((n_cmds++))
      echo "Command $n_cmds: $mousepad --quit" | duperr
      $timeout "$mousepad" --quit 2>&1
    else
      wmctrl -i -c $id
    fi
  else
    pkill -x mousepad
  fi

  # send KILL signal if needed
  wait $pid
  r=$?
  ((r >= 124)) && {
    $timeout pwait -x mousepad 2>&1 &
    pid=$!
    pkill -9 -x mousepad
    wait $pid
    r=$?
  }

  # log results
  [ -s "$out" ] && {
    warnings[n_warns++]=$n_cmds
    sed 's/^/  /' <"$out"
    printf '%s\n\n' "Exit code: $r"
  }

  ((r != 0)) && {
    errors[n_errs++]=$n_cmds
    [ ! -s "$out" ] && printf '%s\n\n' "Exit code: $r"
  }

  # cleanup
  rm "$out"
}

section_is_enabled ()
{
  local regex section parent

  # all sections are enabled
  [ -z "$sections" ] && return 0

  # this section or at least one of its subsections is enabled
  [ "$1" = '--sub' ] && {
    regex=" $2(.[^ ]+)? "
    [[ $sections =~ $regex ]] && return 0
  }

  # this section is enabled (by itself or by one of its parents)
  parent=$1
  while [ "$section" != "$parent" ]; do
    section=$parent
    [[ $sections == *" $section "* ]] && return 0
    parent=${section%.*}
  done

  # this section is not enabled
  return 1
}

create_tempfiles ()
{
  local -i i n=${#tempfiles[@]}
  local    tempfile

  (($1 > 0)) || abort "${FUNCNAME[0]}(): Wrong argument '$1'"

  # create as many new temporary files as needed
  for ((i = $1 - n; i > 0; i--)); do
    tempfile=$(mktemp) || abort 'file' && tempfiles+=("$tempfile")
    base64 /dev/urandom | sed 's/[a-d]/ /g; s/[e-h]/\t/g; 11q' >"$tempfile"
  done
}



### Preamble ###

# Global variables
declare -r timeout='timeout -v -k 5 -- 10' script_name=${0##*/}
declare -a ignored warnings errors tempfiles
declare -i quiet=0 n_warns=0 n_errs=0 n_cmds=0
declare    mousepad logfile sections

# Option parsing
temp=$(getopt -o 'hqc:l:s:i:' \
  -l 'help,quiet,command:,logfile:,section:,list-sections,ignore:' \
  -n "$0" -- "$@"
) || exit 1

eval set -- "$temp" && unset temp

section_list=(
  'non-gui'
  'simple-gui' 'simple-gui.no-file' 'simple-gui.one-file' 'simple-gui.multi-file'
)

while [ "$1" != '--' ]; do
  case $1 in
  '-h'|'--help')
    cat <<EOF
Usage: $script_name [OPTION]...
  -h, --help		Display this help and exit
  -q, --quiet		Do not print any progress indication
  -c, --command=COMMAND	Path to the Mousepad executable to test (default: mousepad in \$PATH)
  -l, --logfile=LOGFILE	Path to the logfile for writing the test report (default: "\$PWD/$script_name.log")
  -s, --section=SECTION	Test section to run (can be used several times, default: all sections)
      --list-sections	List possible test sections to run
  -i, --ignore=PATTERN	Ignore lines containing the ERE PATTERN in Mousepad output on stderr (can be used several times)

Exit code:
  0 when everything is fine
  1 when aborted
  2 when some commands issued warnings
  3 when some commands failed
  5 when 2 and 3
EOF
    exit 0
  ;;
  '-q'|'--quiet')
    quiet=1
  ;;
  '-c'|'--command')
    shift
    mousepad=$1
  ;;
  '-l'|'--logfile')
    shift
    logfile=$1
  ;;
  '-s'|'--section')
    shift

    [[ " ${section_list[*]} " != *" $1 "* ]] && {
      printerr 'error' "Invalid section name '$1'"
      exit 1
    }

    sections+=" $1 "
  ;;
  '--list-sections')
    printf '%s\n' "${section_list[@]}"
    exit 0
  ;;
  '-i'|'--ignore')
    shift
    ignored+=('-e')
    ignored+=("$1")
  ;;
  *)
    printerr 'error' "Invalid option '$1'"
    exit 1
  ;;
  esac

  shift
done

unset section_list

# Checks
mousepad=${mousepad:-'mousepad'}
which "$mousepad" &>/dev/null || {
  printerr 'error' "Command not found '$mousepad'"
  exit 1
}

logfile=${logfile:-"$PWD/$script_name.log"}
[ -d "$logfile" ] && {
  printerr 'error' "'$logfile' is a directory"
  exit 1
}
[ ! -w "$(dirname "$logfile")" ] && {
  printerr 'error' "Directory '$(dirname "$logfile")' is read-only"
  exit 1
}

which xdotool &>/dev/null || {
  printerr 'error' 'xdotool is required but does not seem to be installed'
  exit 1
}

which wmctrl &>/dev/null || {
  printerr 'error' 'wmctrl is required but does not seem to be installed'
  exit 1
}

[ -n "$(pgrep -x mousepad)" ] && {
  printerr 'error' 'Mousepad is running, all Mousepad instances should be terminated before running this script'
  exit 1
}

# Set some global constants
readonly quiet mousepad logfile sections ignored

# From now on we write by default in the logfile
exec 1>"$logfile"



### Main ###

# Non-GUI commands
section_is_enabled 'non-gui' && {
  echo '*** Non-GUI commands ***' | duperr
  test_non_gui --list-encodings
  test_non_gui --version
}

# Simple GUI commands (`mousepad --quit` is implicitly tested each time, except with
# `--disable-server`)
section_is_enabled --sub 'simple-gui' \
  && printf '\n%s\n' '*** Simple GUI commands ***' | duperr

section_is_enabled 'simple-gui.no-file' && {
  echo '- No file -' | duperr
  test_simple_gui
  test_simple_gui --preferences
  test_simple_gui --disable-server
}

section_is_enabled 'simple-gui.one-file' && {
  echo '- One file -' | duperr
  create_tempfiles 1
  test_simple_gui "${tempfiles[0]}"
  test_simple_gui --encoding -- "${tempfiles[0]}"
  test_simple_gui --encoding=ISO-8859-15 -- "${tempfiles[0]}"
  test_simple_gui --line=2 --column=3 -- "${tempfiles[0]}"
}

section_is_enabled 'simple-gui.multi-file' && {
  echo '- Multi-file -' | duperr
  create_tempfiles 2
  test_simple_gui --opening-mode=tab -- "${tempfiles[@]}"
  test_simple_gui --opening-mode=window -- "${tempfiles[@]}"
}

# Outcome
{
  printf '\n%s\n' '*** Outcome ***'
  ((n_warns > 0)) && echo "Some commands issued warnings: numbers ${warnings[*]}"
  ((n_errs > 0)) && echo "Some commands failed: numbers ${errors[*]}"
  ((n_warns == 0 && n_errs == 0)) && echo 'Nothing wrong to report'
} | duperr

# wait a bit until the above has been written on stderr
sleep 0.1
printerr "Full test report written in $logfile"

cleanup

exit $(( 2 * (n_warns > 0) + 3 * (n_errs > 0) ))
